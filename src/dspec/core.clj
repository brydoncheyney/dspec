(ns dspec.core
  (:require [clojure.spec.alpha :as s]))

(def ^:private specs (atom {}))

(defn- conform
  [data problems [k spec]]
  (if (= (s/conform spec (k data)) ::s/invalid)
    (assoc problems k (s/explain-data spec (k data)))
    problems))

(defn- dspec?
  [x]
  (let [problems (reduce (partial conform x) {} (seq @specs))]
    (if (seq problems)
      (throw (ex-info "Invalid input" problems))
      true)))

(defn reset []
  "Resets the internal store of component specs"
  (reset! specs {}))

(defn register
  "Registers a component spec under a given key k"
  [k spec]
  (swap! specs assoc (keyword k) spec))

(defn deregister
  "Deregisters a component key referenced by a given key k"
  [k]
  (swap! specs dissoc (keyword k)))

(defn validate
  "Throws a RuntimeException if value does not match the spec
  dynamically generated by registered components, else the (possibly
  destructured) value.

  Exception ex-data contains the map of s/explain-data in the form

    {:component-a-key {::s/problems '(problem-maps ...)}
     :component-b-key {::s/problems '(problem-maps ...)}}
  "
  [x]
  (s/conform ::dspec x))

(s/def ::dspec dspec?)
